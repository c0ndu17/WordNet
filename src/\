//import java.lang.Iterable;
//import java.util.Iterator;

public class WordNet implements Iterable<String>{

  private Digraph Wordnet;
  private String[][] SynSets;

  @Override
  private class ArrayIterator<E> implements Iterable<String> {
    private String current = SynSets[0][0];
    private int placement = 0;
    public boolean hasNext()  { return placement==SynSets.length-1;  }
    public void remove()      { throw new UnsupportedOperationException();          }

    public String next(){
      if (!hasNext()) throw new ArrayIndexOutOfBoundsException();
      String current = SynSets[0][++placement];
      return current;
    }
  }

  // constructor takes the name of the two input files
  public WordNet(String synsets, String hypernyms) {
    String[] sets = synsets.split("\n");
    SynSets= new String[2][sets.length];
    Wordnet = new Digraph(sets.length);
    for (int i =0; i< sets.length; i++){
      String[] Delimiter = sets[i].split(",");
      SynSets[0][i] = Delimiter[1];
      SynSets[1][i] = Delimiter[2];
//      if(i%30==0)System.out.println(i+ "   " +SynSets[0][i]+ "\t"+ SynSets[1][i]);
    }
    sets = hypernyms.split("\n");
    for(int i = 0; i < sets.length; i++){
      String[] Delimiter = sets[i].split(",");
      int Above = Integer.parseInt(Delimiter[0]);
      for(int j = 1; j< Delimiter.length; j++){
        System.out.println(i + "\t" + j + "\t" +  Delimiter[j]);
        Wordnet.addEdge( Integer.parseInt(Delimiter[j]), Above);
      }
    }
  }

  // returns all WordNet nouns
  public Iterable<String> nouns(){
      ArrayIterator<String> Itty = new ArrayIterator<String>();
      return Itty;
  }

  // is the word a WordNet noun?
  public boolean isNoun (String word){
  for(int i = 0; i< SynSets.length; i++){
    if(SynSets[0][i].equals(word)) return true;
  }
  return false;
  }


  // distance between nounA and nounB (defined below)
  public int distance(String nounA, String nounB){



  return 0;
  }

  // a synset (second field of synsets.txt) that is the common ancestor of nounA and nounB
  // in a shortest ancestral path (defined below)
  public String sap(String nounA, String nounB){
  return "a";
  }

  public void Synprint(){
    for(int i =0; i<SynSets.length; i++){
      System.out.println(i+" " + SynSets[0][i]+ "\t" + SynSets[1][i] );
    }
  }

  // do unit testing of this class
  public static void main(String[] args){
    In fileSynset = new In(args[0]);
    In fileHypernyms = new In(args[1]);
    String Synset = fileSynset.readAll();
    String Hypernyms = fileHypernyms.readAll();
    WordNet Net = new WordNet(Synset, Hypernyms);
    for( String Nouns : Net){
      System.out.println(Nouns);
    }
  }

}
